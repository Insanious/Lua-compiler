Terminals unused in grammar

   FOR
   WHILE
   REPEAT
   DO
   UNTIL
   IN
   MINUS
   MUL
   DIV
   POWER
   MOD
   LESS
   MORE
   LESS_OR_EQUAL
   MORE_OR_EQUAL
   TILDE_EQUAL
   NOT
   AND
   OR
   HASHTAG
   LOCAL
   FUNCTION
   STATIC
   NIL
   DOT
   COLON
   COMMA
   LSQUARE
   RSQUARE
   LCURLY
   RCURLY
   WHITESPACE
   NEWLINE
   OTHER


State 0 conflicts: 2 shift/reduce
State 6 conflicts: 2 shift/reduce, 4 reduce/reduce
State 10 conflicts: 1 shift/reduce
State 35 conflicts: 2 shift/reduce
State 41 conflicts: 2 shift/reduce
State 49 conflicts: 2 shift/reduce


Grammar

    0 $accept: block "end of file"

    1 block: chunk

    2 chunk: stmts
    3      | chunk laststmt
    4      | laststmt

    5 laststmt: %empty
    6         | RETURN exp optsemi
    7         | BREAK optsemi

    8 optsemi: %empty
    9        | SEMICOLON

   10 stmts: stmt optsemi
   11      | stmts stmt optsemi

   12 stmt: if elseifs else END
   13     | var ASSIGNMENT exp

   14 if: IF exp THEN block

   15 elseifs: %empty
   16        | elseif
   17        | elseifs elseif

   18 elseif: ELSEIF exp THEN block

   19 else: %empty
   20     | ELSE block

   21 exp: op

   22 op: op_1
   23   | op EQUALS op_1

   24 op_1: op_last
   25     | op_1 PLUS op_last

   26 op_last: TRUE
   27        | FALSE
   28        | INTEGER
   29        | FLOAT
   30        | STRING
   31        | VAR
   32        | LROUND exp RROUND

   33 var: VAR


Terminals, with rules where they appear

"end of file" (0) 0
error (256)
IF (258) 14
THEN (259) 14 18
ELSEIF (260) 18
ELSE (261) 20
FOR (262)
WHILE (263)
REPEAT (264)
DO (265)
UNTIL (266)
END (267) 12
IN (268)
PLUS (269) 25
MINUS (270)
MUL (271)
DIV (272)
POWER (273)
MOD (274)
EQUALS (275) 23
LESS (276)
MORE (277)
LESS_OR_EQUAL (278)
MORE_OR_EQUAL (279)
TILDE_EQUAL (280)
NOT (281)
AND (282)
OR (283)
HASHTAG (284)
LOCAL (285)
FUNCTION (286)
BREAK (287) 7
RETURN (288) 6
STATIC (289)
NIL (290)
FALSE (291) 27
TRUE (292) 26
INTEGER (293) 28
FLOAT (294) 29
STRING (295) 30
VAR (296) 31 33
ASSIGNMENT (297) 13
DOT (298)
COLON (299)
SEMICOLON (300) 9
COMMA (301)
LROUND (302) 32
RROUND (303) 32
LSQUARE (304)
RSQUARE (305)
LCURLY (306)
RCURLY (307)
WHITESPACE (308)
NEWLINE (309)
OTHER (310)


Nonterminals, with rules where they appear

$accept (56)
    on left: 0
block (57)
    on left: 1, on right: 0 14 18 20
chunk (58)
    on left: 2 3 4, on right: 1 3
laststmt (59)
    on left: 5 6 7, on right: 3 4
optsemi (60)
    on left: 8 9, on right: 6 7 10 11
stmts (61)
    on left: 10 11, on right: 2 11
stmt (62)
    on left: 12 13, on right: 10 11
if (63)
    on left: 14, on right: 12
elseifs (64)
    on left: 15 16 17, on right: 12 17
elseif (65)
    on left: 18, on right: 16 17
else (66)
    on left: 19 20, on right: 12
exp (67)
    on left: 21, on right: 6 13 14 18 32
op (68)
    on left: 22 23, on right: 21 23
op_1 (69)
    on left: 24 25, on right: 22 23 25
op_last (70)
    on left: 26 27 28 29 30 31 32, on right: 24 25
var (71)
    on left: 33, on right: 13


State 0

    0 $accept: . block "end of file"

    IF      shift, and go to state 1
    BREAK   shift, and go to state 2
    RETURN  shift, and go to state 3
    VAR     shift, and go to state 4

    BREAK     [reduce using rule 5 (laststmt)]
    RETURN    [reduce using rule 5 (laststmt)]
    $default  reduce using rule 5 (laststmt)

    block     go to state 5
    chunk     go to state 6
    laststmt  go to state 7
    stmts     go to state 8
    stmt      go to state 9
    if        go to state 10
    var       go to state 11


State 1

   14 if: IF . exp THEN block

    FALSE    shift, and go to state 12
    TRUE     shift, and go to state 13
    INTEGER  shift, and go to state 14
    FLOAT    shift, and go to state 15
    STRING   shift, and go to state 16
    VAR      shift, and go to state 17
    LROUND   shift, and go to state 18

    exp      go to state 19
    op       go to state 20
    op_1     go to state 21
    op_last  go to state 22


State 2

    7 laststmt: BREAK . optsemi

    SEMICOLON  shift, and go to state 23

    $default  reduce using rule 8 (optsemi)

    optsemi  go to state 24


State 3

    6 laststmt: RETURN . exp optsemi

    FALSE    shift, and go to state 12
    TRUE     shift, and go to state 13
    INTEGER  shift, and go to state 14
    FLOAT    shift, and go to state 15
    STRING   shift, and go to state 16
    VAR      shift, and go to state 17
    LROUND   shift, and go to state 18

    exp      go to state 25
    op       go to state 20
    op_1     go to state 21
    op_last  go to state 22


State 4

   33 var: VAR .

    $default  reduce using rule 33 (var)


State 5

    0 $accept: block . "end of file"

    "end of file"  shift, and go to state 26


State 6

    1 block: chunk .
    3 chunk: chunk . laststmt

    BREAK   shift, and go to state 2
    RETURN  shift, and go to state 3

    "end of file"  reduce using rule 1 (block)
    "end of file"  [reduce using rule 5 (laststmt)]
    ELSEIF         reduce using rule 1 (block)
    ELSEIF         [reduce using rule 5 (laststmt)]
    ELSE           reduce using rule 1 (block)
    ELSE           [reduce using rule 5 (laststmt)]
    END            reduce using rule 1 (block)
    END            [reduce using rule 5 (laststmt)]
    BREAK          [reduce using rule 5 (laststmt)]
    RETURN         [reduce using rule 5 (laststmt)]
    $default       reduce using rule 1 (block)

    laststmt  go to state 27


State 7

    4 chunk: laststmt .

    $default  reduce using rule 4 (chunk)


State 8

    2 chunk: stmts .
   11 stmts: stmts . stmt optsemi

    IF   shift, and go to state 1
    VAR  shift, and go to state 4

    $default  reduce using rule 2 (chunk)

    stmt  go to state 28
    if    go to state 10
    var   go to state 11


State 9

   10 stmts: stmt . optsemi

    SEMICOLON  shift, and go to state 23

    $default  reduce using rule 8 (optsemi)

    optsemi  go to state 29


State 10

   12 stmt: if . elseifs else END

    ELSEIF  shift, and go to state 30

    ELSEIF    [reduce using rule 15 (elseifs)]
    $default  reduce using rule 15 (elseifs)

    elseifs  go to state 31
    elseif   go to state 32


State 11

   13 stmt: var . ASSIGNMENT exp

    ASSIGNMENT  shift, and go to state 33


State 12

   27 op_last: FALSE .

    $default  reduce using rule 27 (op_last)


State 13

   26 op_last: TRUE .

    $default  reduce using rule 26 (op_last)


State 14

   28 op_last: INTEGER .

    $default  reduce using rule 28 (op_last)


State 15

   29 op_last: FLOAT .

    $default  reduce using rule 29 (op_last)


State 16

   30 op_last: STRING .

    $default  reduce using rule 30 (op_last)


State 17

   31 op_last: VAR .

    $default  reduce using rule 31 (op_last)


State 18

   32 op_last: LROUND . exp RROUND

    FALSE    shift, and go to state 12
    TRUE     shift, and go to state 13
    INTEGER  shift, and go to state 14
    FLOAT    shift, and go to state 15
    STRING   shift, and go to state 16
    VAR      shift, and go to state 17
    LROUND   shift, and go to state 18

    exp      go to state 34
    op       go to state 20
    op_1     go to state 21
    op_last  go to state 22


State 19

   14 if: IF exp . THEN block

    THEN  shift, and go to state 35


State 20

   21 exp: op .
   23 op: op . EQUALS op_1

    EQUALS  shift, and go to state 36

    $default  reduce using rule 21 (exp)


State 21

   22 op: op_1 .
   25 op_1: op_1 . PLUS op_last

    PLUS  shift, and go to state 37

    $default  reduce using rule 22 (op)


State 22

   24 op_1: op_last .

    $default  reduce using rule 24 (op_1)


State 23

    9 optsemi: SEMICOLON .

    $default  reduce using rule 9 (optsemi)


State 24

    7 laststmt: BREAK optsemi .

    $default  reduce using rule 7 (laststmt)


State 25

    6 laststmt: RETURN exp . optsemi

    SEMICOLON  shift, and go to state 23

    $default  reduce using rule 8 (optsemi)

    optsemi  go to state 38


State 26

    0 $accept: block "end of file" .

    $default  accept


State 27

    3 chunk: chunk laststmt .

    $default  reduce using rule 3 (chunk)


State 28

   11 stmts: stmts stmt . optsemi

    SEMICOLON  shift, and go to state 23

    $default  reduce using rule 8 (optsemi)

    optsemi  go to state 39


State 29

   10 stmts: stmt optsemi .

    $default  reduce using rule 10 (stmts)


State 30

   18 elseif: ELSEIF . exp THEN block

    FALSE    shift, and go to state 12
    TRUE     shift, and go to state 13
    INTEGER  shift, and go to state 14
    FLOAT    shift, and go to state 15
    STRING   shift, and go to state 16
    VAR      shift, and go to state 17
    LROUND   shift, and go to state 18

    exp      go to state 40
    op       go to state 20
    op_1     go to state 21
    op_last  go to state 22


State 31

   12 stmt: if elseifs . else END
   17 elseifs: elseifs . elseif

    ELSEIF  shift, and go to state 30
    ELSE    shift, and go to state 41

    $default  reduce using rule 19 (else)

    elseif  go to state 42
    else    go to state 43


State 32

   16 elseifs: elseif .

    $default  reduce using rule 16 (elseifs)


State 33

   13 stmt: var ASSIGNMENT . exp

    FALSE    shift, and go to state 12
    TRUE     shift, and go to state 13
    INTEGER  shift, and go to state 14
    FLOAT    shift, and go to state 15
    STRING   shift, and go to state 16
    VAR      shift, and go to state 17
    LROUND   shift, and go to state 18

    exp      go to state 44
    op       go to state 20
    op_1     go to state 21
    op_last  go to state 22


State 34

   32 op_last: LROUND exp . RROUND

    RROUND  shift, and go to state 45


State 35

   14 if: IF exp THEN . block

    IF      shift, and go to state 1
    BREAK   shift, and go to state 2
    RETURN  shift, and go to state 3
    VAR     shift, and go to state 4

    BREAK     [reduce using rule 5 (laststmt)]
    RETURN    [reduce using rule 5 (laststmt)]
    $default  reduce using rule 5 (laststmt)

    block     go to state 46
    chunk     go to state 6
    laststmt  go to state 7
    stmts     go to state 8
    stmt      go to state 9
    if        go to state 10
    var       go to state 11


State 36

   23 op: op EQUALS . op_1

    FALSE    shift, and go to state 12
    TRUE     shift, and go to state 13
    INTEGER  shift, and go to state 14
    FLOAT    shift, and go to state 15
    STRING   shift, and go to state 16
    VAR      shift, and go to state 17
    LROUND   shift, and go to state 18

    op_1     go to state 47
    op_last  go to state 22


State 37

   25 op_1: op_1 PLUS . op_last

    FALSE    shift, and go to state 12
    TRUE     shift, and go to state 13
    INTEGER  shift, and go to state 14
    FLOAT    shift, and go to state 15
    STRING   shift, and go to state 16
    VAR      shift, and go to state 17
    LROUND   shift, and go to state 18

    op_last  go to state 48


State 38

    6 laststmt: RETURN exp optsemi .

    $default  reduce using rule 6 (laststmt)


State 39

   11 stmts: stmts stmt optsemi .

    $default  reduce using rule 11 (stmts)


State 40

   18 elseif: ELSEIF exp . THEN block

    THEN  shift, and go to state 49


State 41

   20 else: ELSE . block

    IF      shift, and go to state 1
    BREAK   shift, and go to state 2
    RETURN  shift, and go to state 3
    VAR     shift, and go to state 4

    BREAK     [reduce using rule 5 (laststmt)]
    RETURN    [reduce using rule 5 (laststmt)]
    $default  reduce using rule 5 (laststmt)

    block     go to state 50
    chunk     go to state 6
    laststmt  go to state 7
    stmts     go to state 8
    stmt      go to state 9
    if        go to state 10
    var       go to state 11


State 42

   17 elseifs: elseifs elseif .

    $default  reduce using rule 17 (elseifs)


State 43

   12 stmt: if elseifs else . END

    END  shift, and go to state 51


State 44

   13 stmt: var ASSIGNMENT exp .

    $default  reduce using rule 13 (stmt)


State 45

   32 op_last: LROUND exp RROUND .

    $default  reduce using rule 32 (op_last)


State 46

   14 if: IF exp THEN block .

    $default  reduce using rule 14 (if)


State 47

   23 op: op EQUALS op_1 .
   25 op_1: op_1 . PLUS op_last

    PLUS  shift, and go to state 37

    $default  reduce using rule 23 (op)


State 48

   25 op_1: op_1 PLUS op_last .

    $default  reduce using rule 25 (op_1)


State 49

   18 elseif: ELSEIF exp THEN . block

    IF      shift, and go to state 1
    BREAK   shift, and go to state 2
    RETURN  shift, and go to state 3
    VAR     shift, and go to state 4

    BREAK     [reduce using rule 5 (laststmt)]
    RETURN    [reduce using rule 5 (laststmt)]
    $default  reduce using rule 5 (laststmt)

    block     go to state 52
    chunk     go to state 6
    laststmt  go to state 7
    stmts     go to state 8
    stmt      go to state 9
    if        go to state 10
    var       go to state 11


State 50

   20 else: ELSE block .

    $default  reduce using rule 20 (else)


State 51

   12 stmt: if elseifs else END .

    $default  reduce using rule 12 (stmt)


State 52

   18 elseif: ELSEIF exp THEN block .

    $default  reduce using rule 18 (elseif)
