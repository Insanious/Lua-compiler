Terminals unused in grammar

    FOR
    WHILE
    REPEAT
    DO
    UNTIL
    IN
    MUL
    DIV
    POWER
    MOD
    LESS
    MORE
    LESS_OR_EQUAL
    MORE_OR_EQUAL
    TILDE_EQUAL
    NOT
    AND
    OR
    HASHTAG
    LOCAL
    FUNCTION
    NIL
    DOT
    COLON
    COMMA
    LSQUARE
    RSQUARE
    LCURLY
    RCURLY
    WHITESPACE
    NEWLINE
    OTHER


State 0 conflicts: 2 shift/reduce
State 7 conflicts: 2 shift/reduce, 4 reduce/reduce
State 11 conflicts: 1 shift/reduce
State 37 conflicts: 2 shift/reduce
State 44 conflicts: 2 shift/reduce
State 53 conflicts: 2 shift/reduce


Grammar

    0 $accept: block "end of file"

    1 block: chunk

    2 chunk: stmts
    3      | chunk laststmt
    4      | laststmt

    5 laststmt: %empty
    6         | RETURN exp optsemi
    7         | BREAK optsemi

    8 optsemi: %empty
    9        | SEMICOLON

   10 stmts: stmt optsemi
   11      | stmts stmt optsemi

   12 stmt: if elseifs else END
   13     | var ASSIGNMENT exp
   14     | PRINT exp

   15 if: IF exp THEN block

   16 elseifs: %empty
   17        | elseif
   18        | elseifs elseif

   19 elseif: ELSEIF exp THEN block

   20 else: %empty
   21     | ELSE block

   22 exp: op

   23 op: op_1
   24   | op EQUALS op_1

   25 op_1: op_last
   26     | op_1 PLUS op_last
   27     | op_1 MINUS op_last

   28 op_last: TRUE
   29        | FALSE
   30        | INTEGER
   31        | FLOAT
   32        | STRING
   33        | VAR
   34        | LROUND exp RROUND

   35 var: VAR


Terminals, with rules where they appear

    "end of file" (0) 0
    error (256)
    IF <std::string> (258) 15
    THEN <std::string> (259) 15 19
    ELSEIF <std::string> (260) 19
    ELSE <std::string> (261) 21
    FOR <std::string> (262)
    WHILE <std::string> (263)
    REPEAT <std::string> (264)
    DO <std::string> (265)
    UNTIL <std::string> (266)
    END <std::string> (267) 12
    IN <std::string> (268)
    PLUS <std::string> (269) 26
    MINUS <std::string> (270) 27
    MUL <std::string> (271)
    DIV <std::string> (272)
    POWER <std::string> (273)
    MOD <std::string> (274)
    EQUALS <std::string> (275) 24
    LESS <std::string> (276)
    MORE <std::string> (277)
    LESS_OR_EQUAL <std::string> (278)
    MORE_OR_EQUAL <std::string> (279)
    TILDE_EQUAL <std::string> (280)
    NOT <std::string> (281)
    AND <std::string> (282)
    OR <std::string> (283)
    HASHTAG <std::string> (284)
    LOCAL <std::string> (285)
    FUNCTION <std::string> (286)
    BREAK <std::string> (287) 7
    RETURN <std::string> (288) 6
    PRINT <std::string> (289) 14
    NIL <std::string> (290)
    FALSE <std::string> (291) 29
    TRUE <std::string> (292) 28
    INTEGER <int> (293) 30
    FLOAT <float> (294) 31
    STRING <std::string> (295) 32
    VAR <std::string> (296) 33 35
    ASSIGNMENT <std::string> (297) 13
    DOT <std::string> (298)
    COLON <std::string> (299)
    SEMICOLON <std::string> (300) 9
    COMMA <std::string> (301)
    LROUND <std::string> (302) 34
    RROUND <std::string> (303) 34
    LSQUARE <std::string> (304)
    RSQUARE <std::string> (305)
    LCURLY <std::string> (306)
    RCURLY <std::string> (307)
    WHITESPACE <std::string> (308)
    NEWLINE <std::string> (309)
    OTHER <std::string> (310)


Nonterminals, with rules where they appear

    $accept (56)
        on left: 0
    block <Statement*> (57)
        on left: 1
        on right: 0 15 19 21
    chunk <std::vector<Statement*>> (58)
        on left: 2 3 4
        on right: 1 3
    laststmt <Statement*> (59)
        on left: 5 6 7
        on right: 3 4
    optsemi <Statement*> (60)
        on left: 8 9
        on right: 6 7 10 11
    stmts <std::vector<Statement*>> (61)
        on left: 10 11
        on right: 2 11
    stmt <Statement*> (62)
        on left: 12 13 14
        on right: 10 11
    if <Statement*> (63)
        on left: 15
        on right: 12
    elseifs <std::vector<Statement*>> (64)
        on left: 16 17 18
        on right: 12 18
    elseif <Statement*> (65)
        on left: 19
        on right: 17 18
    else <Statement*> (66)
        on left: 20 21
        on right: 12
    exp <Expression*> (67)
        on left: 22
        on right: 6 13 14 15 19 34
    op <Expression*> (68)
        on left: 23 24
        on right: 22 24
    op_1 <Expression*> (69)
        on left: 25 26 27
        on right: 23 24 26 27
    op_last <Expression*> (70)
        on left: 28 29 30 31 32 33 34
        on right: 25 26 27
    var <Expression*> (71)
        on left: 35
        on right: 13


State 0

    0 $accept: . block "end of file"

    IF      shift, and go to state 1
    BREAK   shift, and go to state 2
    RETURN  shift, and go to state 3
    PRINT   shift, and go to state 4
    VAR     shift, and go to state 5

    BREAK     [reduce using rule 5 (laststmt)]
    RETURN    [reduce using rule 5 (laststmt)]
    $default  reduce using rule 5 (laststmt)

    block     go to state 6
    chunk     go to state 7
    laststmt  go to state 8
    stmts     go to state 9
    stmt      go to state 10
    if        go to state 11
    var       go to state 12


State 1

   15 if: IF . exp THEN block

    FALSE    shift, and go to state 13
    TRUE     shift, and go to state 14
    INTEGER  shift, and go to state 15
    FLOAT    shift, and go to state 16
    STRING   shift, and go to state 17
    VAR      shift, and go to state 18
    LROUND   shift, and go to state 19

    exp      go to state 20
    op       go to state 21
    op_1     go to state 22
    op_last  go to state 23


State 2

    7 laststmt: BREAK . optsemi

    SEMICOLON  shift, and go to state 24

    $default  reduce using rule 8 (optsemi)

    optsemi  go to state 25


State 3

    6 laststmt: RETURN . exp optsemi

    FALSE    shift, and go to state 13
    TRUE     shift, and go to state 14
    INTEGER  shift, and go to state 15
    FLOAT    shift, and go to state 16
    STRING   shift, and go to state 17
    VAR      shift, and go to state 18
    LROUND   shift, and go to state 19

    exp      go to state 26
    op       go to state 21
    op_1     go to state 22
    op_last  go to state 23


State 4

   14 stmt: PRINT . exp

    FALSE    shift, and go to state 13
    TRUE     shift, and go to state 14
    INTEGER  shift, and go to state 15
    FLOAT    shift, and go to state 16
    STRING   shift, and go to state 17
    VAR      shift, and go to state 18
    LROUND   shift, and go to state 19

    exp      go to state 27
    op       go to state 21
    op_1     go to state 22
    op_last  go to state 23


State 5

   35 var: VAR .

    $default  reduce using rule 35 (var)


State 6

    0 $accept: block . "end of file"

    "end of file"  shift, and go to state 28


State 7

    1 block: chunk .
    3 chunk: chunk . laststmt

    BREAK   shift, and go to state 2
    RETURN  shift, and go to state 3

    "end of file"  reduce using rule 1 (block)
    "end of file"  [reduce using rule 5 (laststmt)]
    ELSEIF         reduce using rule 1 (block)
    ELSEIF         [reduce using rule 5 (laststmt)]
    ELSE           reduce using rule 1 (block)
    ELSE           [reduce using rule 5 (laststmt)]
    END            reduce using rule 1 (block)
    END            [reduce using rule 5 (laststmt)]
    BREAK          [reduce using rule 5 (laststmt)]
    RETURN         [reduce using rule 5 (laststmt)]
    $default       reduce using rule 1 (block)

    laststmt  go to state 29


State 8

    4 chunk: laststmt .

    $default  reduce using rule 4 (chunk)


State 9

    2 chunk: stmts .
   11 stmts: stmts . stmt optsemi

    IF     shift, and go to state 1
    PRINT  shift, and go to state 4
    VAR    shift, and go to state 5

    $default  reduce using rule 2 (chunk)

    stmt  go to state 30
    if    go to state 11
    var   go to state 12


State 10

   10 stmts: stmt . optsemi

    SEMICOLON  shift, and go to state 24

    $default  reduce using rule 8 (optsemi)

    optsemi  go to state 31


State 11

   12 stmt: if . elseifs else END

    ELSEIF  shift, and go to state 32

    ELSEIF    [reduce using rule 16 (elseifs)]
    $default  reduce using rule 16 (elseifs)

    elseifs  go to state 33
    elseif   go to state 34


State 12

   13 stmt: var . ASSIGNMENT exp

    ASSIGNMENT  shift, and go to state 35


State 13

   29 op_last: FALSE .

    $default  reduce using rule 29 (op_last)


State 14

   28 op_last: TRUE .

    $default  reduce using rule 28 (op_last)


State 15

   30 op_last: INTEGER .

    $default  reduce using rule 30 (op_last)


State 16

   31 op_last: FLOAT .

    $default  reduce using rule 31 (op_last)


State 17

   32 op_last: STRING .

    $default  reduce using rule 32 (op_last)


State 18

   33 op_last: VAR .

    $default  reduce using rule 33 (op_last)


State 19

   34 op_last: LROUND . exp RROUND

    FALSE    shift, and go to state 13
    TRUE     shift, and go to state 14
    INTEGER  shift, and go to state 15
    FLOAT    shift, and go to state 16
    STRING   shift, and go to state 17
    VAR      shift, and go to state 18
    LROUND   shift, and go to state 19

    exp      go to state 36
    op       go to state 21
    op_1     go to state 22
    op_last  go to state 23


State 20

   15 if: IF exp . THEN block

    THEN  shift, and go to state 37


State 21

   22 exp: op .
   24 op: op . EQUALS op_1

    EQUALS  shift, and go to state 38

    $default  reduce using rule 22 (exp)


State 22

   23 op: op_1 .
   26 op_1: op_1 . PLUS op_last
   27     | op_1 . MINUS op_last

    PLUS   shift, and go to state 39
    MINUS  shift, and go to state 40

    $default  reduce using rule 23 (op)


State 23

   25 op_1: op_last .

    $default  reduce using rule 25 (op_1)


State 24

    9 optsemi: SEMICOLON .

    $default  reduce using rule 9 (optsemi)


State 25

    7 laststmt: BREAK optsemi .

    $default  reduce using rule 7 (laststmt)


State 26

    6 laststmt: RETURN exp . optsemi

    SEMICOLON  shift, and go to state 24

    $default  reduce using rule 8 (optsemi)

    optsemi  go to state 41


State 27

   14 stmt: PRINT exp .

    $default  reduce using rule 14 (stmt)


State 28

    0 $accept: block "end of file" .

    $default  accept


State 29

    3 chunk: chunk laststmt .

    $default  reduce using rule 3 (chunk)


State 30

   11 stmts: stmts stmt . optsemi

    SEMICOLON  shift, and go to state 24

    $default  reduce using rule 8 (optsemi)

    optsemi  go to state 42


State 31

   10 stmts: stmt optsemi .

    $default  reduce using rule 10 (stmts)


State 32

   19 elseif: ELSEIF . exp THEN block

    FALSE    shift, and go to state 13
    TRUE     shift, and go to state 14
    INTEGER  shift, and go to state 15
    FLOAT    shift, and go to state 16
    STRING   shift, and go to state 17
    VAR      shift, and go to state 18
    LROUND   shift, and go to state 19

    exp      go to state 43
    op       go to state 21
    op_1     go to state 22
    op_last  go to state 23


State 33

   12 stmt: if elseifs . else END
   18 elseifs: elseifs . elseif

    ELSEIF  shift, and go to state 32
    ELSE    shift, and go to state 44

    $default  reduce using rule 20 (else)

    elseif  go to state 45
    else    go to state 46


State 34

   17 elseifs: elseif .

    $default  reduce using rule 17 (elseifs)


State 35

   13 stmt: var ASSIGNMENT . exp

    FALSE    shift, and go to state 13
    TRUE     shift, and go to state 14
    INTEGER  shift, and go to state 15
    FLOAT    shift, and go to state 16
    STRING   shift, and go to state 17
    VAR      shift, and go to state 18
    LROUND   shift, and go to state 19

    exp      go to state 47
    op       go to state 21
    op_1     go to state 22
    op_last  go to state 23


State 36

   34 op_last: LROUND exp . RROUND

    RROUND  shift, and go to state 48


State 37

   15 if: IF exp THEN . block

    IF      shift, and go to state 1
    BREAK   shift, and go to state 2
    RETURN  shift, and go to state 3
    PRINT   shift, and go to state 4
    VAR     shift, and go to state 5

    BREAK     [reduce using rule 5 (laststmt)]
    RETURN    [reduce using rule 5 (laststmt)]
    $default  reduce using rule 5 (laststmt)

    block     go to state 49
    chunk     go to state 7
    laststmt  go to state 8
    stmts     go to state 9
    stmt      go to state 10
    if        go to state 11
    var       go to state 12


State 38

   24 op: op EQUALS . op_1

    FALSE    shift, and go to state 13
    TRUE     shift, and go to state 14
    INTEGER  shift, and go to state 15
    FLOAT    shift, and go to state 16
    STRING   shift, and go to state 17
    VAR      shift, and go to state 18
    LROUND   shift, and go to state 19

    op_1     go to state 50
    op_last  go to state 23


State 39

   26 op_1: op_1 PLUS . op_last

    FALSE    shift, and go to state 13
    TRUE     shift, and go to state 14
    INTEGER  shift, and go to state 15
    FLOAT    shift, and go to state 16
    STRING   shift, and go to state 17
    VAR      shift, and go to state 18
    LROUND   shift, and go to state 19

    op_last  go to state 51


State 40

   27 op_1: op_1 MINUS . op_last

    FALSE    shift, and go to state 13
    TRUE     shift, and go to state 14
    INTEGER  shift, and go to state 15
    FLOAT    shift, and go to state 16
    STRING   shift, and go to state 17
    VAR      shift, and go to state 18
    LROUND   shift, and go to state 19

    op_last  go to state 52


State 41

    6 laststmt: RETURN exp optsemi .

    $default  reduce using rule 6 (laststmt)


State 42

   11 stmts: stmts stmt optsemi .

    $default  reduce using rule 11 (stmts)


State 43

   19 elseif: ELSEIF exp . THEN block

    THEN  shift, and go to state 53


State 44

   21 else: ELSE . block

    IF      shift, and go to state 1
    BREAK   shift, and go to state 2
    RETURN  shift, and go to state 3
    PRINT   shift, and go to state 4
    VAR     shift, and go to state 5

    BREAK     [reduce using rule 5 (laststmt)]
    RETURN    [reduce using rule 5 (laststmt)]
    $default  reduce using rule 5 (laststmt)

    block     go to state 54
    chunk     go to state 7
    laststmt  go to state 8
    stmts     go to state 9
    stmt      go to state 10
    if        go to state 11
    var       go to state 12


State 45

   18 elseifs: elseifs elseif .

    $default  reduce using rule 18 (elseifs)


State 46

   12 stmt: if elseifs else . END

    END  shift, and go to state 55


State 47

   13 stmt: var ASSIGNMENT exp .

    $default  reduce using rule 13 (stmt)


State 48

   34 op_last: LROUND exp RROUND .

    $default  reduce using rule 34 (op_last)


State 49

   15 if: IF exp THEN block .

    $default  reduce using rule 15 (if)


State 50

   24 op: op EQUALS op_1 .
   26 op_1: op_1 . PLUS op_last
   27     | op_1 . MINUS op_last

    PLUS   shift, and go to state 39
    MINUS  shift, and go to state 40

    $default  reduce using rule 24 (op)


State 51

   26 op_1: op_1 PLUS op_last .

    $default  reduce using rule 26 (op_1)


State 52

   27 op_1: op_1 MINUS op_last .

    $default  reduce using rule 27 (op_1)


State 53

   19 elseif: ELSEIF exp THEN . block

    IF      shift, and go to state 1
    BREAK   shift, and go to state 2
    RETURN  shift, and go to state 3
    PRINT   shift, and go to state 4
    VAR     shift, and go to state 5

    BREAK     [reduce using rule 5 (laststmt)]
    RETURN    [reduce using rule 5 (laststmt)]
    $default  reduce using rule 5 (laststmt)

    block     go to state 56
    chunk     go to state 7
    laststmt  go to state 8
    stmts     go to state 9
    stmt      go to state 10
    if        go to state 11
    var       go to state 12


State 54

   21 else: ELSE block .

    $default  reduce using rule 21 (else)


State 55

   12 stmt: if elseifs else END .

    $default  reduce using rule 12 (stmt)


State 56

   19 elseif: ELSEIF exp THEN block .

    $default  reduce using rule 19 (elseif)
