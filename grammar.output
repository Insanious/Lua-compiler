Terminals unused in grammar

    FOR
    WHILE
    REPEAT
    DO
    UNTIL
    IN
    MUL
    DIV
    POWER
    MOD
    LESS
    MORE
    LESS_OR_EQUAL
    MORE_OR_EQUAL
    TILDE_EQUAL
    NOT
    AND
    OR
    HASHTAG
    LOCAL
    FUNCTION
    STATIC
    NIL
    DOT
    COLON
    COMMA
    LSQUARE
    RSQUARE
    LCURLY
    RCURLY
    WHITESPACE
    NEWLINE
    OTHER


State 0 conflicts: 2 shift/reduce
State 6 conflicts: 2 shift/reduce, 4 reduce/reduce
State 10 conflicts: 1 shift/reduce
State 35 conflicts: 2 shift/reduce
State 42 conflicts: 2 shift/reduce
State 51 conflicts: 2 shift/reduce


Grammar

    0 $accept: block "end of file"

    1 block: chunk

    2 chunk: stmts
    3      | chunk laststmt
    4      | laststmt

    5 laststmt: %empty
    6         | RETURN exp optsemi
    7         | BREAK optsemi

    8 optsemi: %empty
    9        | SEMICOLON

   10 stmts: stmt optsemi
   11      | stmts stmt optsemi

   12 stmt: if elseifs else END
   13     | var ASSIGNMENT exp

   14 if: IF exp THEN block

   15 elseifs: %empty
   16        | elseif
   17        | elseifs elseif

   18 elseif: ELSEIF exp THEN block

   19 else: %empty
   20     | ELSE block

   21 exp: op

   22 op: op_1
   23   | op EQUALS op_1

   24 op_1: op_last
   25     | op_1 PLUS op_last
   26     | op_1 MINUS op_last

   27 op_last: TRUE
   28        | FALSE
   29        | INTEGER
   30        | FLOAT
   31        | STRING
   32        | VAR
   33        | LROUND exp RROUND

   34 var: VAR


Terminals, with rules where they appear

    "end of file" (0) 0
    error (256)
    IF <std::string> (258) 14
    THEN <std::string> (259) 14 18
    ELSEIF <std::string> (260) 18
    ELSE <std::string> (261) 20
    FOR <std::string> (262)
    WHILE <std::string> (263)
    REPEAT <std::string> (264)
    DO <std::string> (265)
    UNTIL <std::string> (266)
    END <std::string> (267) 12
    IN <std::string> (268)
    PLUS <std::string> (269) 25
    MINUS <std::string> (270) 26
    MUL <std::string> (271)
    DIV <std::string> (272)
    POWER <std::string> (273)
    MOD <std::string> (274)
    EQUALS <std::string> (275) 23
    LESS <std::string> (276)
    MORE <std::string> (277)
    LESS_OR_EQUAL <std::string> (278)
    MORE_OR_EQUAL <std::string> (279)
    TILDE_EQUAL <std::string> (280)
    NOT <std::string> (281)
    AND <std::string> (282)
    OR <std::string> (283)
    HASHTAG <std::string> (284)
    LOCAL <std::string> (285)
    FUNCTION <std::string> (286)
    BREAK <std::string> (287) 7
    RETURN <std::string> (288) 6
    STATIC <std::string> (289)
    NIL <std::string> (290)
    FALSE <std::string> (291) 28
    TRUE <std::string> (292) 27
    INTEGER <int> (293) 29
    FLOAT <float> (294) 30
    STRING <std::string> (295) 31
    VAR <std::string> (296) 32 34
    ASSIGNMENT <std::string> (297) 13
    DOT <std::string> (298)
    COLON <std::string> (299)
    SEMICOLON <std::string> (300) 9
    COMMA <std::string> (301)
    LROUND <std::string> (302) 33
    RROUND <std::string> (303) 33
    LSQUARE <std::string> (304)
    RSQUARE <std::string> (305)
    LCURLY <std::string> (306)
    RCURLY <std::string> (307)
    WHITESPACE <std::string> (308)
    NEWLINE <std::string> (309)
    OTHER <std::string> (310)


Nonterminals, with rules where they appear

    $accept (56)
        on left: 0
    block <Statement*> (57)
        on left: 1
        on right: 0 14 18 20
    chunk <std::vector<Statement*>> (58)
        on left: 2 3 4
        on right: 1 3
    laststmt <Statement*> (59)
        on left: 5 6 7
        on right: 3 4
    optsemi <Statement*> (60)
        on left: 8 9
        on right: 6 7 10 11
    stmts <std::vector<Statement*>> (61)
        on left: 10 11
        on right: 2 11
    stmt <Statement*> (62)
        on left: 12 13
        on right: 10 11
    if <Statement*> (63)
        on left: 14
        on right: 12
    elseifs <std::vector<Statement*>> (64)
        on left: 15 16 17
        on right: 12 17
    elseif <Statement*> (65)
        on left: 18
        on right: 16 17
    else <Statement*> (66)
        on left: 19 20
        on right: 12
    exp <Expression*> (67)
        on left: 21
        on right: 6 13 14 18 33
    op <Expression*> (68)
        on left: 22 23
        on right: 21 23
    op_1 <Expression*> (69)
        on left: 24 25 26
        on right: 22 23 25 26
    op_last <Expression*> (70)
        on left: 27 28 29 30 31 32 33
        on right: 24 25 26
    var <Expression*> (71)
        on left: 34
        on right: 13


State 0

    0 $accept: . block "end of file"

    IF      shift, and go to state 1
    BREAK   shift, and go to state 2
    RETURN  shift, and go to state 3
    VAR     shift, and go to state 4

    BREAK     [reduce using rule 5 (laststmt)]
    RETURN    [reduce using rule 5 (laststmt)]
    $default  reduce using rule 5 (laststmt)

    block     go to state 5
    chunk     go to state 6
    laststmt  go to state 7
    stmts     go to state 8
    stmt      go to state 9
    if        go to state 10
    var       go to state 11


State 1

   14 if: IF . exp THEN block

    FALSE    shift, and go to state 12
    TRUE     shift, and go to state 13
    INTEGER  shift, and go to state 14
    FLOAT    shift, and go to state 15
    STRING   shift, and go to state 16
    VAR      shift, and go to state 17
    LROUND   shift, and go to state 18

    exp      go to state 19
    op       go to state 20
    op_1     go to state 21
    op_last  go to state 22


State 2

    7 laststmt: BREAK . optsemi

    SEMICOLON  shift, and go to state 23

    $default  reduce using rule 8 (optsemi)

    optsemi  go to state 24


State 3

    6 laststmt: RETURN . exp optsemi

    FALSE    shift, and go to state 12
    TRUE     shift, and go to state 13
    INTEGER  shift, and go to state 14
    FLOAT    shift, and go to state 15
    STRING   shift, and go to state 16
    VAR      shift, and go to state 17
    LROUND   shift, and go to state 18

    exp      go to state 25
    op       go to state 20
    op_1     go to state 21
    op_last  go to state 22


State 4

   34 var: VAR .

    $default  reduce using rule 34 (var)


State 5

    0 $accept: block . "end of file"

    "end of file"  shift, and go to state 26


State 6

    1 block: chunk .
    3 chunk: chunk . laststmt

    BREAK   shift, and go to state 2
    RETURN  shift, and go to state 3

    "end of file"  reduce using rule 1 (block)
    "end of file"  [reduce using rule 5 (laststmt)]
    ELSEIF         reduce using rule 1 (block)
    ELSEIF         [reduce using rule 5 (laststmt)]
    ELSE           reduce using rule 1 (block)
    ELSE           [reduce using rule 5 (laststmt)]
    END            reduce using rule 1 (block)
    END            [reduce using rule 5 (laststmt)]
    BREAK          [reduce using rule 5 (laststmt)]
    RETURN         [reduce using rule 5 (laststmt)]
    $default       reduce using rule 1 (block)

    laststmt  go to state 27


State 7

    4 chunk: laststmt .

    $default  reduce using rule 4 (chunk)


State 8

    2 chunk: stmts .
   11 stmts: stmts . stmt optsemi

    IF   shift, and go to state 1
    VAR  shift, and go to state 4

    $default  reduce using rule 2 (chunk)

    stmt  go to state 28
    if    go to state 10
    var   go to state 11


State 9

   10 stmts: stmt . optsemi

    SEMICOLON  shift, and go to state 23

    $default  reduce using rule 8 (optsemi)

    optsemi  go to state 29


State 10

   12 stmt: if . elseifs else END

    ELSEIF  shift, and go to state 30

    ELSEIF    [reduce using rule 15 (elseifs)]
    $default  reduce using rule 15 (elseifs)

    elseifs  go to state 31
    elseif   go to state 32


State 11

   13 stmt: var . ASSIGNMENT exp

    ASSIGNMENT  shift, and go to state 33


State 12

   28 op_last: FALSE .

    $default  reduce using rule 28 (op_last)


State 13

   27 op_last: TRUE .

    $default  reduce using rule 27 (op_last)


State 14

   29 op_last: INTEGER .

    $default  reduce using rule 29 (op_last)


State 15

   30 op_last: FLOAT .

    $default  reduce using rule 30 (op_last)


State 16

   31 op_last: STRING .

    $default  reduce using rule 31 (op_last)


State 17

   32 op_last: VAR .

    $default  reduce using rule 32 (op_last)


State 18

   33 op_last: LROUND . exp RROUND

    FALSE    shift, and go to state 12
    TRUE     shift, and go to state 13
    INTEGER  shift, and go to state 14
    FLOAT    shift, and go to state 15
    STRING   shift, and go to state 16
    VAR      shift, and go to state 17
    LROUND   shift, and go to state 18

    exp      go to state 34
    op       go to state 20
    op_1     go to state 21
    op_last  go to state 22


State 19

   14 if: IF exp . THEN block

    THEN  shift, and go to state 35


State 20

   21 exp: op .
   23 op: op . EQUALS op_1

    EQUALS  shift, and go to state 36

    $default  reduce using rule 21 (exp)


State 21

   22 op: op_1 .
   25 op_1: op_1 . PLUS op_last
   26     | op_1 . MINUS op_last

    PLUS   shift, and go to state 37
    MINUS  shift, and go to state 38

    $default  reduce using rule 22 (op)


State 22

   24 op_1: op_last .

    $default  reduce using rule 24 (op_1)


State 23

    9 optsemi: SEMICOLON .

    $default  reduce using rule 9 (optsemi)


State 24

    7 laststmt: BREAK optsemi .

    $default  reduce using rule 7 (laststmt)


State 25

    6 laststmt: RETURN exp . optsemi

    SEMICOLON  shift, and go to state 23

    $default  reduce using rule 8 (optsemi)

    optsemi  go to state 39


State 26

    0 $accept: block "end of file" .

    $default  accept


State 27

    3 chunk: chunk laststmt .

    $default  reduce using rule 3 (chunk)


State 28

   11 stmts: stmts stmt . optsemi

    SEMICOLON  shift, and go to state 23

    $default  reduce using rule 8 (optsemi)

    optsemi  go to state 40


State 29

   10 stmts: stmt optsemi .

    $default  reduce using rule 10 (stmts)


State 30

   18 elseif: ELSEIF . exp THEN block

    FALSE    shift, and go to state 12
    TRUE     shift, and go to state 13
    INTEGER  shift, and go to state 14
    FLOAT    shift, and go to state 15
    STRING   shift, and go to state 16
    VAR      shift, and go to state 17
    LROUND   shift, and go to state 18

    exp      go to state 41
    op       go to state 20
    op_1     go to state 21
    op_last  go to state 22


State 31

   12 stmt: if elseifs . else END
   17 elseifs: elseifs . elseif

    ELSEIF  shift, and go to state 30
    ELSE    shift, and go to state 42

    $default  reduce using rule 19 (else)

    elseif  go to state 43
    else    go to state 44


State 32

   16 elseifs: elseif .

    $default  reduce using rule 16 (elseifs)


State 33

   13 stmt: var ASSIGNMENT . exp

    FALSE    shift, and go to state 12
    TRUE     shift, and go to state 13
    INTEGER  shift, and go to state 14
    FLOAT    shift, and go to state 15
    STRING   shift, and go to state 16
    VAR      shift, and go to state 17
    LROUND   shift, and go to state 18

    exp      go to state 45
    op       go to state 20
    op_1     go to state 21
    op_last  go to state 22


State 34

   33 op_last: LROUND exp . RROUND

    RROUND  shift, and go to state 46


State 35

   14 if: IF exp THEN . block

    IF      shift, and go to state 1
    BREAK   shift, and go to state 2
    RETURN  shift, and go to state 3
    VAR     shift, and go to state 4

    BREAK     [reduce using rule 5 (laststmt)]
    RETURN    [reduce using rule 5 (laststmt)]
    $default  reduce using rule 5 (laststmt)

    block     go to state 47
    chunk     go to state 6
    laststmt  go to state 7
    stmts     go to state 8
    stmt      go to state 9
    if        go to state 10
    var       go to state 11


State 36

   23 op: op EQUALS . op_1

    FALSE    shift, and go to state 12
    TRUE     shift, and go to state 13
    INTEGER  shift, and go to state 14
    FLOAT    shift, and go to state 15
    STRING   shift, and go to state 16
    VAR      shift, and go to state 17
    LROUND   shift, and go to state 18

    op_1     go to state 48
    op_last  go to state 22


State 37

   25 op_1: op_1 PLUS . op_last

    FALSE    shift, and go to state 12
    TRUE     shift, and go to state 13
    INTEGER  shift, and go to state 14
    FLOAT    shift, and go to state 15
    STRING   shift, and go to state 16
    VAR      shift, and go to state 17
    LROUND   shift, and go to state 18

    op_last  go to state 49


State 38

   26 op_1: op_1 MINUS . op_last

    FALSE    shift, and go to state 12
    TRUE     shift, and go to state 13
    INTEGER  shift, and go to state 14
    FLOAT    shift, and go to state 15
    STRING   shift, and go to state 16
    VAR      shift, and go to state 17
    LROUND   shift, and go to state 18

    op_last  go to state 50


State 39

    6 laststmt: RETURN exp optsemi .

    $default  reduce using rule 6 (laststmt)


State 40

   11 stmts: stmts stmt optsemi .

    $default  reduce using rule 11 (stmts)


State 41

   18 elseif: ELSEIF exp . THEN block

    THEN  shift, and go to state 51


State 42

   20 else: ELSE . block

    IF      shift, and go to state 1
    BREAK   shift, and go to state 2
    RETURN  shift, and go to state 3
    VAR     shift, and go to state 4

    BREAK     [reduce using rule 5 (laststmt)]
    RETURN    [reduce using rule 5 (laststmt)]
    $default  reduce using rule 5 (laststmt)

    block     go to state 52
    chunk     go to state 6
    laststmt  go to state 7
    stmts     go to state 8
    stmt      go to state 9
    if        go to state 10
    var       go to state 11


State 43

   17 elseifs: elseifs elseif .

    $default  reduce using rule 17 (elseifs)


State 44

   12 stmt: if elseifs else . END

    END  shift, and go to state 53


State 45

   13 stmt: var ASSIGNMENT exp .

    $default  reduce using rule 13 (stmt)


State 46

   33 op_last: LROUND exp RROUND .

    $default  reduce using rule 33 (op_last)


State 47

   14 if: IF exp THEN block .

    $default  reduce using rule 14 (if)


State 48

   23 op: op EQUALS op_1 .
   25 op_1: op_1 . PLUS op_last
   26     | op_1 . MINUS op_last

    PLUS   shift, and go to state 37
    MINUS  shift, and go to state 38

    $default  reduce using rule 23 (op)


State 49

   25 op_1: op_1 PLUS op_last .

    $default  reduce using rule 25 (op_1)


State 50

   26 op_1: op_1 MINUS op_last .

    $default  reduce using rule 26 (op_1)


State 51

   18 elseif: ELSEIF exp THEN . block

    IF      shift, and go to state 1
    BREAK   shift, and go to state 2
    RETURN  shift, and go to state 3
    VAR     shift, and go to state 4

    BREAK     [reduce using rule 5 (laststmt)]
    RETURN    [reduce using rule 5 (laststmt)]
    $default  reduce using rule 5 (laststmt)

    block     go to state 54
    chunk     go to state 6
    laststmt  go to state 7
    stmts     go to state 8
    stmt      go to state 9
    if        go to state 10
    var       go to state 11


State 52

   20 else: ELSE block .

    $default  reduce using rule 20 (else)


State 53

   12 stmt: if elseifs else END .

    $default  reduce using rule 12 (stmt)


State 54

   18 elseif: ELSEIF exp THEN block .

    $default  reduce using rule 18 (elseif)
